-- Fix infinite recursion in RLS policies for clients and appointments tables

-- Drop existing problematic policies
DROP POLICY IF EXISTS "Companies can view their clients" ON public.clients;
DROP POLICY IF EXISTS "Users can view appointments related to them" ON public.appointments;

-- Create security definer functions to avoid recursion
CREATE OR REPLACE FUNCTION public.get_user_companies()
RETURNS TABLE(company_id uuid) AS $$
  SELECT id FROM public.companies WHERE user_id = auth.uid();
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION public.get_user_client_id()
RETURNS uuid AS $$
  SELECT id FROM public.clients WHERE user_id = auth.uid() LIMIT 1;
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Recreate policies using security definer functions
CREATE POLICY "Companies can view their clients"
ON public.clients FOR SELECT
USING (
  id IN (
    SELECT DISTINCT a.client_id
    FROM public.appointments a
    WHERE a.company_id IN (SELECT company_id FROM public.get_user_companies())
  )
);

CREATE POLICY "Users can view appointments related to them"
ON public.appointments FOR SELECT
USING (
  client_id = public.get_user_client_id() OR
  company_id IN (SELECT company_id FROM public.get_user_companies())
);

-- Create likes table for universal like system (authenticated and anonymous users)
CREATE TABLE IF NOT EXISTS public.likes (
  id bigint generated by default as identity primary key,
  target_type text not null,        -- ex: 'company' | 'service' | 'post'
  target_id uuid not null,          -- or text/int, depending on your model
  client_key text not null,         -- 'user:<userId>' or 'anon:<uuid>'
  created_at timestamp with time zone default now(),
  unique (target_type, target_id, client_key)
);

-- Enable RLS on likes table
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

-- Policies for likes (allow liking and listing without login)
CREATE POLICY "likes_select_anyone"
ON public.likes FOR SELECT
TO anon, authenticated
USING (true);

CREATE POLICY "likes_insert_anyone"
ON public.likes FOR INSERT
TO anon, authenticated
WITH CHECK (true);

-- Allow removing own likes (auth and anonymous users)
-- Note: for authenticated users, client_key = 'user:<uid>'
-- For anonymous users, client_key = 'anon:<uuid from localStorage>'
CREATE POLICY "likes_delete_own"
ON public.likes FOR DELETE
TO anon, authenticated
USING (
  case
    when position('user:' in client_key) = 1
      then split_part(client_key, ':', 2) = auth.uid()::text
    else true  -- anonymous users can delete likes with their client_key
  end
);